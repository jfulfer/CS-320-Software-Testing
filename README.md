# CS-320-Software-Testing

# 1. How can I ensure that my code, program, or software is functional and secure?
To ensure that my software is functional, I rely on a combination of testing, reviews, and careful planning. I start by writing unit tests to check if individual parts of the program work as intended and then move on to integration tests to see how those parts interact. Regular testing during development helps identify and fix problems early. I also value feedback through code reviews, where others can point out issues I may have missed or suggest improvements.

For security, I focus on protecting the program from potential threats. This includes validating all user inputs to prevent attacks like SQL injection and ensuring that sensitive data, such as passwords, is encrypted. I keep my tools and dependencies updated to address any vulnerabilities, and I try to follow well-known security guidelines, like the ones from OWASP, to make sure my software is as secure as possible.

# 2. How do I interpret user needs and incorporate them into a program?
Interpreting user needs starts with gathering feedback. I might conduct interviews, surveys, or observe how users interact with similar tools. This helps me understand their goals and the challenges they face. For example, if users are looking for an easy way to manage tasks, they might want a program with a clean interface and reminders.

Once I understand their needs, I translate them into requirements—specific features or behaviors the software should have. I make sure to prioritize these based on what users find most important. While developing the program, I often share prototypes or early versions with users to confirm that I’m meeting their expectations. This ongoing feedback helps ensure the final product aligns with their needs.

# 3. How do I approach designing software?
When designing software, I start by defining its purpose and who it’s for. For example, if the goal is to build a tool for students to track assignments, I would focus on features like creating reminders, organizing tasks, and making the interface simple to use. Once the goal is clear, I sketch out a plan for how the program will work, often using diagrams or flowcharts to map out the key components.

After planning, I break the design into smaller, manageable parts. This modular approach makes the program easier to build, test, and maintain. I aim for simplicity and flexibility, so it’s possible to add new features in the future. Finally, I document my design choices to ensure that both I and others working on the project can easily understand how the system is structured.
